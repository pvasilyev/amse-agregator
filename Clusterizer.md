# Кластеризация #

Эта часть отвечает за обработку сырых данных и создание базы, готовой к индексации. Задача кластеризации найти дубликаты элементов, соединить их и поместить в базу в единственном экземпляре.

15.12.10

# Устройство и архитектура кластеризации #

Все классы, относящиеся к кластризации лежат в пакете `ru.amse.agregator.quality.clusterization` и его подпакетах.

## Запуск ##

Запустить класс `ru.amse.agregator.quality.clusterization.ClusterizationProcess`.

## Архитектура и классы компонента ##

За взаимодействие частей компонента отвечает выше упомянутый класс `ClusterizationProcess` , который реализует всю высокоуровневую логику процесса. Собственно логика:

  1. Выкачать из базы часть объектов и подготовить их к кластризации. (реализовано методами базы)
  1. Создать граф похожести между объектами. (абстрактный класс `Graph` и пока что его единственная реализация `ArrayGraph`, находятся в подпакете `simgraph`)
  1. Напустить на граф алгоритм кластеризации (абстрактный класс `Clusterizer` и пока что его единственная реализация `PartitionClusterizer`, находятся в основном пакете)
  1. На выходе 3его шага получаем набор кластеров (классы `ClusterStorage` и `ArrayStorage` в подпакете `clusterstorage`)
  1. Набор кластеров передаётся в класс `MergeProcess`(подпакет `merge`), где кластеры соединяются в единый объект и добавляются в базу.

Далее повторить весь процесс для другого набора объектов.


### Метрика ###


За сравнение объектов при создании графа отвечает класс `Metric`, есть 2 его реализации: `NameMetric` простая метрика сравнивающая лишь имена объектов, `StandardMetric` сравнивает также имена связей (если таковые имеются). (находятся в подпакете `metric`)


### Процесс соединения ###

Высокоуровневую логику этого процесса реализует класс `MergeProcess`. Этот класс применяет на вход алгоритм мерджа (реализованный классом `ClusterMerger`), который соединяет весь кластер и единственный объект, и затем полученный объект добавляет в базу.

Текущая имплементация `ClusterMerger` - класс `ObjectMerger` работает так:

Есть множество потомков класса `AttributeMerger`, который является абстрактным алгоритмом, отвечающим за обработку одного атрибута (поля объекта базы). `ObjectMerger` знает каким `AttributeMerger`'ом обрабатывать какой атрибут и занимается фактически только этим.
На данный момент реализованы следующие `AttributeMerger`'ы:

  * `CountryIdMerger`, `ContinentIdMerger`, `CityIdMeger` отвечают за обработку связей в базе
  * `CoordinateMerger` - обработка координат
  * `StringListMerger` - соединяет списки строк, например списки ключевых слов или url
  * `StringMerger` - соединяет строки
  * `DoNothingMerger` - ничего не делает, нужен для служебных или пока не обрабатываемых полей
  * `DesciptionMerger` - соединяет описания.

### `DesciptionMerger` ###

Этот класс реализует сравнение по отпечаткам(класс `Fingerprint`) на основе частотных словарей(класс `FrequencyList`). Текущая реализация сравнивает множества слов в описаниях и на основании этого делается вывод о похожести описаний (при этом фильтруются наиболее часто встречаемые слова, за это отвечают классы `TextFingerprinter` и `DescriptionFingerprinter`).

# Что в ближайших планах #

  * Попробовать использовать стеммер при составлении частотных словарей, сравнить результаты.

  * Написать простейшую оценку качества и отсеивать объекты, для которых заведомо известно, что при кластрезации их будет сложно определить в нужный кластер.

13.02.2011

Добавил возможность обновлять базу. Теперь clusterizer.jar принимает 2 аргумента. Первый: имя базы которую надо добавить к главной.(по-умолчанию Database.DIRTY\_DB\_NAME, сейчас она называется 'DirtyDB'). Второй это ключ. Два ожидаемых значения ключа -u (только обновлять и добавлять записи в базу, является ключом по-умолчанию) и -r (предварительно полностью удаляет чистую базу).